\documentclass{article}
\usepackage{graphicx}
\usepackage{amsmath,cite}
\title{Solving small shogi}
\author{I. van Duijn \\ Utrecht University}
\begin{document}
\maketitle

\section{Abstract}
%TODO

\section{Introduction}
Even since before
%TODO
%Research area of solving games.
%The game of shogi and relevant topics.
%Various methods for solving, PN is chosen.

\section{Method}
We are dealing with generic small sized shogi variants, so representation and algorithms employed have to be sufficiently generic as well.
A small shogi variant is defined by the size of the board, the initial configuration of black (white's is $180\deg$ rotationally symmetrical) and
the size of the promotion zone. The initial configuration consists of a set of pieces, each of which has one or two move sets (taking into account
promotion). Any algorithm that aims to prove the game theoretical value of a variant then only has to have access to two functions based on this
definition: a move generator which can map positions to a set of successing positions, and an evaluation function which recognises terminal
positions and computes their value.

\subsection{Representation}
As state before, we have to be able to generically represent board positions. A well known technique in computer chess, bitboards, has been
shown ~\cite{grimbergen2007using} to be fairly effective in shogi as well. A bitboard is a bit pattern of (at least) the size of the board,
in which each bit encodes some information (e.g. if it is occupied) about the corresponding square. Since the size of the bit pattern can
easily be increased to accomodate larger boards, they are well suited for our purpose. Also, as will be explained later, they allow for easy
generic move generation.

In the current implementation, a position is represented by one bitboard per player per piece's move set (unpromoted and promoted), plus an additional
bitboard per player containing the pieces in hand. Each bitboard corresponding to a certain piece's move set represents all pieces of that type
owned by a specific player. For an $n \times m$ board, each bitboard is fitted in the smallest $nm \leq 2^k$-bit word (for small
variants $16$ or $32$ bit integers). %TODO: example

To generate moves, we essentially need two things. We need to know for each individual piece where it is, and where it can move to in its current state.
The location of each individual piece can easily be extracted from the bitboards representing a position. To determine where it can move to, a table
is generated which maps position bitboards to move bitboards. %TODO illustrate with example

Finally, the evaluation function \note{This function gives the game theoretical value of a position, not a heuristical value.}  can use the move
generator to check whether any move captures the opponent's king.

With the move generator and the evaluation function in place, we have an implicit definition of the game tree. The main problem of proving the game
theoretical value efficiently is only generating relevant parts of the tree.

\subsection{Proof-number Search}
Proof-number search ~\cite{allis1994proof} is an algorithm designed to find the game theoretical value of a game tree. It successively expands the
\textit{most promising} node in the tree untill the root can be proved. It has been succesfully applied in many domains, such as ... ~\cite{seo2001pn}.

%TODO description of PN-search, how detailed?

\paragraph{Breadth-first search}
For comparison there is also a simple breadth-first search implementation.

\section{Result}
%subsection: PN failed

%subsection: Combinatorial splosions.

\section{Discussion}

\end{document}
