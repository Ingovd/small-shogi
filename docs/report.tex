\documentclass{article}
\usepackage{graphicx}
\usepackage{amsmath,cite}
\title{Solving small shogi}
\author{I. van Duijn \\ Utrecht University}
\begin{document}
\maketitle

\section{Abstract}
%TODO

\section{Introduction}
Ever since the early days of modern computers there has been great interest in chess programming ~\cite{shannon1950xxii}. Initial
focus in the west was mainly on chess and checkers, but when computers were well established in Japan as well, researchers there adopted
many techniques many techniques from computer chess and applied them to their local chess variant, shogi.

\subsection{shogi}%TODO relevant citations
Shogi (Japanese chess) is a game similar to western chess. It is played on a $9 \times 9$ board and every
player has 20 pieces, some of which correspond to western pieces and others are slightly different.
The main difference between shogi and chess is the so called drop rule.
A piece that is captured by a player now belongs to him and can be placed on \textit{any} vacant square in one of his subsequent turns
(in stead moving a piece already on the board).
This extra rule dramatically increases the game tree complexity of shogi as compared to chess, see Table ? for a comparison.\\
%TODO: tabel

Computer shogi is an active field of research. The main interest there is how we can program computers 
such that their play peers with -- and eventually even surpasses -- human professional players. Shogi, being complexer
than western chess, has a game tree too large to make exhaustive search even near feasible. Consequently, research
focusses on clever ways to search the game tree in order to find a good heuristic. Many techniques from computer chess
can be employed, but the drop rule introduces such a difference that new shogi-specific techniques have to be developed.\\

Unlike in western chess, end game situations
in shogi are not significantly less complex than mid game situations. In fact, any board configuration resulting from the standard
starting setup has exactly 40 pieces in play. Because of this there is no database with solved end games for shogi.
However, in shogi, so called mating problems, which resemble end game situations, are extensively studied. There exist several
programs that can completely solve a lot of these problems, some of which are quite large. Unfortunately solutions to these shogi mating problems
are not the equivalent of solutions to western chess end games; in shogi, such a solution cannot be directly applied to find a winning move.

%Various methods for solving, PN is chosen.

\section{Method}
We are dealing with generic small sized shogi variants, so representation and algorithms employed have to be sufficiently generic as well.
A small shogi variant is defined by the size of the board, the initial configuration of black (white's is $180\deg$ rotationally symmetrical) and
the size of the promotion zone. The initial configuration consists of a set of pieces, each of which has one or two move sets (taking into account
promotion). Any algorithm that aims to prove the game theoretical value of a variant then only has to have access to two functions based on this
definition: a move generator which can map positions to a set of successing positions, and an evaluation function which recognises terminal
positions and computes their value.

\subsection{Representation}
As state before, we have to be able to generically represent board positions. A well known technique in computer chess, bitboards, has been
shown ~\cite{grimbergen2007using} to be fairly effective in shogi as well. A bitboard is a bit pattern of (at least) the size of the board,
in which each bit encodes some information (e.g. if it is occupied) about the corresponding square. Since the size of the bit pattern can
easily be increased to accomodate larger boards, they are well suited for our purpose. Also, as will be explained later, they allow for easy
generic move generation.

In the current implementation, a position is represented by one bitboard per player per piece's move set (unpromoted and promoted), plus an additional
bitboard per player containing the pieces in hand. Each bitboard corresponding to a certain piece's move set represents all pieces of that type
owned by a specific player. For an $n \times m$ board, each bitboard is fitted in the smallest $nm \leq 2^k$-bit word (for small
variants $16$ or $32$ bit integers). %TODO: example

To generate moves, we essentially need two things. We need to know for each individual piece where it is, and where it can move to in its current state.
The location of each individual piece can easily be extracted from the bitboards representing a position. To determine where it can move to, a table
is generated which maps position bitboards to move bitboards. %TODO illustrate with example

Finally, the evaluation function can use the move generator to check whether any move captures the opponent's king. Note that the evaluation function
does not give a heuristical value, it only evaluates terminal positions to nonzero values ($1$ for win and $-1$ for loss).

With the move generator and the evaluation function in place, we have an implicit definition of the game tree. The main problem of proving the game
theoretical value efficiently is only generating relevant parts of the tree.

\subsection{Proof-number Search}
Proof-number search ~\cite{allis1994proof} is an algorithm designed to find the game theoretical value of a game tree. It successively expands the
\textit{most promising} node in the tree untill the root can be proved. It has been succesfully applied in many domains, such as ... ~\cite{seo2001pn}.

%TODO description of PN-search, how detailed?

\paragraph{Breadth-first search}
For comparison there is also a simple breadth-first search implementation.

\section{Result}
%subsection: PN failed

%subsection: Combinatorial splosions.

\section{Discussion}

\end{document}
